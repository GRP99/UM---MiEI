
import org.alicebot.ab.Bot;
import org.alicebot.ab.Chat;
import org.alicebot.ab.MagicBooleans;
import org.alicebot.ab.MagicStrings;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * @author Gonï¿½alo Pinto
 */
// Class Server to interact with multiple clients
public class ServerJFrame extends javax.swing.JFrame {

    static ServerSocket server;
    static Socket socket;
    static DataInputStream inputStream;
    static DataOutputStream outputStream;

    // List to save all words associate a emotion
    private static final List<String> positive = new ArrayList<>();
    private static final List<String> negative = new ArrayList<>();
    private static final List<String> anger = new ArrayList<>();
    private static final List<String> anticipation = new ArrayList<>();
    private static final List<String> disgust = new ArrayList<>();
    private static final List<String> fear = new ArrayList<>();
    private static final List<String> joy = new ArrayList<>();
    private static final List<String> sadness = new ArrayList<>();
    private static final List<String> surprise = new ArrayList<>();
    private static final List<String> trust = new ArrayList<>();

    private static FileWriter fr;
    private static Bot bot;

    /**
     * Creates new form ServerJFrame
     */
    public ServerJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        conversation = new javax.swing.JTextArea();
        fieldserver = new javax.swing.JTextField();
        send = new javax.swing.JButton();
        static_conversation = new javax.swing.JLabel();
        static_suggestion = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        suggestion = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Server - Chat");
        setPreferredSize(new java.awt.Dimension(700, 500));
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        conversation.setEditable(false);
        conversation.setColumns(20);
        conversation.setRows(5);
        conversation.setPreferredSize(new java.awt.Dimension(185, 75));
        jScrollPane1.setViewportView(conversation);

        fieldserver.setHorizontalAlignment(javax.swing.JTextField.LEFT);

        send.setText("Send");
        send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendActionPerformed(evt);
            }
        });

        static_conversation.setFont(new java.awt.Font("Tahoma", 3, 24)); // NOI18N
        static_conversation.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        static_conversation.setText("Conversation");
        static_conversation.setPreferredSize(new java.awt.Dimension(150, 30));

        static_suggestion.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        static_suggestion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        static_suggestion.setText("Suggestion :");

        suggestion.setEditable(false);
        suggestion.setColumns(20);
        suggestion.setRows(5);
        jScrollPane2.setViewportView(suggestion);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(static_suggestion, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(fieldserver)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(send, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(230, 230, 230)
                .addComponent(static_conversation, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(234, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(static_conversation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 331, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(static_suggestion, javax.swing.GroupLayout.DEFAULT_SIZE, 44, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(fieldserver, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                    .addComponent(send))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void sendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendActionPerformed
        // TODO add your handling code here:
        try {
            String textServer;

            // Read what server write
            textServer = fieldserver.getText().trim();

            if (!textServer.equals("exit")) {
                // Write the message in chat
                conversation.setText(conversation.getText().trim() + "\n>SERVER : " + textServer + " ( " + getEmotion(textServer) + " ) ");
            }

            // Clean fields
            fieldserver.setText("");
            suggestion.setText("");

            // Send to client
            outputStream.writeUTF(textServer);

        } catch (Exception e) {
        }
    }//GEN-LAST:event_sendActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // TODO add your handling code here:
        // One way chatterbot learn
        bot.writeQuit();

        System.exit(0);
    }//GEN-LAST:event_formWindowClosing

    // Split the text by spaces and for each word associate a number of emotion
    // Give the emotion with highest value or instead alphabetical order or Neutral with don't found emotions
    private static String getEmotion(String text) {
        String emotion = "Neutral";
        String cvsSplitBy = " ";
        int max = 0;

        TreeMap<String, Integer> emotionmap = new TreeMap<>();

        String[] dados = text.split(cvsSplitBy);

        for (int i = 0; i < dados.length; i++) {
            if (positive.contains(dados[i])) {
                if (emotionmap.containsKey("positive")) {
                    int value = emotionmap.get("positive");
                    value = value + 1;
                    emotionmap.replace("positive", value);
                } else {
                    emotionmap.put("positive", 1);
                }
            }
            if (negative.contains(dados[i])) {
                if (emotionmap.containsKey("negative")) {
                    int value = emotionmap.get("negative");
                    value = value + 1;
                    emotionmap.replace("negative", value);
                } else {
                    emotionmap.put("negative", 1);
                }
            }
            if (anger.contains(dados[i])) {
                if (emotionmap.containsKey("anger")) {
                    int value = emotionmap.get("anger");
                    value = value + 1;
                    emotionmap.replace("anger", value);
                } else {
                    emotionmap.put("anger", 1);
                }
            }
            if (anticipation.contains(dados[i])) {
                if (emotionmap.containsKey("anticipation")) {
                    int value = emotionmap.get("anticipation");
                    value = value + 1;
                    emotionmap.replace("anticipation", value);
                } else {
                    emotionmap.put("anticipation", 1);
                }
            }
            if (disgust.contains(dados[i])) {
                if (emotionmap.containsKey("disgust")) {
                    int value = emotionmap.get("disgust");
                    value = value + 1;
                    emotionmap.replace("disgust", value);
                } else {
                    emotionmap.put("disgust", 1);
                }
            }
            if (fear.contains(dados[i])) {
                if (emotionmap.containsKey("fear")) {
                    int value = emotionmap.get("fear");
                    value = value + 1;
                    emotionmap.replace("fear", value);
                } else {
                    emotionmap.put("fear", 1);
                }
            }
            if (joy.contains(dados[i])) {
                if (emotionmap.containsKey("joy")) {
                    int value = emotionmap.get("joy");
                    value = value + 1;
                    emotionmap.replace("joy", value);
                } else {
                    emotionmap.put("joy", 1);
                }
            }
            if (sadness.contains(dados[i])) {
                if (emotionmap.containsKey("sadness")) {
                    int value = emotionmap.get("sadness");
                    value = value + 1;
                    emotionmap.replace("sadness", value);
                } else {
                    emotionmap.put("sadness", 1);
                }
            }
            if (surprise.contains(dados[i])) {
                if (emotionmap.containsKey("surprise")) {
                    int value = emotionmap.get("surprise");
                    value = value + 1;
                    emotionmap.replace("surprise", value);
                } else {
                    emotionmap.put("surprise", 1);
                }
            }
            if (trust.contains(dados[i])) {
                if (emotionmap.containsKey("trust")) {
                    int value = emotionmap.get("trust");
                    value = value + 1;
                    emotionmap.replace("trust", value);
                } else {
                    emotionmap.put("trust", 1);
                }
            }
        }

        if (emotionmap.size() != 0) {
            for (Map.Entry<String, Integer> stringIntegerEntry : emotionmap.entrySet()) {
                if (stringIntegerEntry.getValue() > max) {
                    max = stringIntegerEntry.getValue();
                    emotion = stringIntegerEntry.getKey();
                }
            }
        }

        return emotion;
    }

    // Get the resources
    private static String getResourcesPath() {
        File currDir = new File(".");
        String path = currDir.getAbsolutePath();
        path = path.substring(0, path.length() - 2);
        return path + File.separator + "src" + File.separator + "main" + File.separator + "resources";
    }

    // Search all csv file given and fills in the list with respective emotion
    private static void registerEmotions(String csvFile) throws IOException {
        String line = "";
        String cvsSplitBy = ";";
        int i = 0;

        BufferedReader br = new BufferedReader(new FileReader(csvFile));

        while ((line = br.readLine()) != null) {
            String[] dados = line.split(cvsSplitBy);
            if (i != 0) {
                if (dados.length == 11) {
                    if (Integer.parseInt(dados[1]) == 1) {
                        positive.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[2]) == 1) {
                        negative.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[3]) == 1) {
                        anger.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[4]) == 1) {
                        anticipation.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[5]) == 1) {
                        disgust.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[6]) == 1) {
                        fear.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[7]) == 1) {
                        joy.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[8]) == 1) {
                        sadness.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[9]) == 1) {
                        surprise.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[10]) == 1) {
                        trust.add(dados[0]);
                    }
                }
            }
            i++;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ServerJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ServerJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ServerJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ServerJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ServerJFrame().setVisible(true);
            }
        });

        try {
            registerEmotions("csv\\NRC-Emotion-Lexicon.csv");

            server = new ServerSocket(12345);
            System.out.println("Server started...");

            while (true) {
                System.out.println("Waiting for a client ...");
                socket = server.accept();
                inputStream = new DataInputStream(socket.getInputStream());
                outputStream = new DataOutputStream(socket.getOutputStream());

                /* CHATTERBOT */
                MagicBooleans.trace_mode = false;
                // Create a bot with name super and all AIML files present in resources directory
                bot = new Bot("super", getResourcesPath());
                // Create a chatSession to learn in conversation and get the previous messages
                Chat chatSession = new Chat(new Bot("super", getResourcesPath()));
                bot.brain.nodeStats();

                String textClient = "";
                while (!textClient.equals("exit")) {
                    // Read what client send
                    textClient = inputStream.readUTF();

                    if (!textClient.equals("exit")) {
                        conversation.setText(conversation.getText().trim() + "\n-CLIENT : " + textClient + " ( " + getEmotion(textClient) + " ) ");
                    }

                    if ((textClient == null) || (textClient.length() < 1)) {
                        textClient = MagicStrings.null_input;
                    } else if (!(textClient.equals("exit"))) {
                        if (MagicBooleans.trace_mode) {
                            System.out.println("STATE=" + textClient + ":THAT=" + chatSession.thatHistory.get(0).get(0) + ":TOPIC=" + chatSession.predicates.get("topic"));
                        }

                        // Get the answer give by chatterbot dependent of text that human write
                        String response = chatSession.multisentenceRespond(textClient);

                        while (response.contains("&lt;")) {
                            response = response.replace("&lt;", "<");
                        }
                        while (response.contains("&gt;")) {
                            response = response.replace("&gt;", ">");
                        }

                        // Write what chatterbot like a suggestion
                        suggestion.setText(response);

                    }
                }

                // When the client disconnected the fields are clean
                conversation.setText("");
                suggestion.setText("");

                // One way chatterbot learn
                bot.writeQuit();

                System.out.println("Closing connection");
                socket.shutdownOutput();
                socket.shutdownInput();
                socket.close();
            }
        } catch (Exception e) {
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JTextArea conversation;
    private javax.swing.JTextField fieldserver;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton send;
    private javax.swing.JLabel static_conversation;
    private javax.swing.JLabel static_suggestion;
    private static javax.swing.JTextArea suggestion;
    // End of variables declaration//GEN-END:variables
}
