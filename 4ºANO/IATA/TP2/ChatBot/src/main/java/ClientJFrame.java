
import org.alicebot.ab.Bot;
import org.alicebot.ab.Chat;
import org.alicebot.ab.MagicBooleans;
import org.alicebot.ab.MagicStrings;

import java.io.*;
import java.net.Socket;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * @author Gonï¿½alo Pinto
 */
// Class Client to interact with the server
public class ClientJFrame extends javax.swing.JFrame {
    static Socket socket;
    static DataInputStream inputStream;
    static DataOutputStream outputStream;

    // List to save all words associate a emotion
    private static final List<String> positive = new ArrayList<>();
    private static final List<String> negative = new ArrayList<>();
    private static final List<String> anger = new ArrayList<>();
    private static final List<String> anticipation = new ArrayList<>();
    private static final List<String> disgust = new ArrayList<>();
    private static final List<String> fear = new ArrayList<>();
    private static final List<String> joy = new ArrayList<>();
    private static final List<String> sadness = new ArrayList<>();
    private static final List<String> surprise = new ArrayList<>();
    private static final List<String> trust = new ArrayList<>();

    private static FileWriter fr;
    private static Bot bot;

    /**
     * Creates new form ClientJFrame
     */
    public ClientJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fix_conversation = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        conversation = new javax.swing.JTextArea();
        fieldclient = new javax.swing.JTextField();
        send = new javax.swing.JButton();
        fix_suggestion = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        suggestion = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Client - Chat");
        setPreferredSize(new java.awt.Dimension(700, 500));
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                try {
                    formWindowClosing(evt);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });

        fix_conversation.setFont(new java.awt.Font("Tahoma", 3, 24)); // NOI18N
        fix_conversation.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        fix_conversation.setText("Conversation");
        fix_conversation.setAlignmentY(0.0F);
        fix_conversation.setPreferredSize(new java.awt.Dimension(150, 30));

        conversation.setEditable(false);
        conversation.setColumns(20);
        conversation.setRows(5);
        conversation.setPreferredSize(new java.awt.Dimension(185, 75));
        jScrollPane2.setViewportView(conversation);

        send.setText("Send");
        send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendActionPerformed(evt);
            }
        });

        fix_suggestion.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        fix_suggestion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        fix_suggestion.setText("Suggestion :");

        suggestion.setEditable(false);
        suggestion.setColumns(20);
        suggestion.setRows(5);
        jScrollPane1.setViewportView(suggestion);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(fieldclient)
                                .addGap(18, 18, 18)
                                .addComponent(send, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(fix_suggestion)
                                .addGap(11, 11, 11)
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 632, Short.MAX_VALUE)))
                        .addGap(10, 10, 10))))
            .addGroup(layout.createSequentialGroup()
                .addGap(238, 238, 238)
                .addComponent(fix_conversation, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(7, 7, 7)
                .addComponent(fix_conversation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 343, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(fix_suggestion, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(fieldclient, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                    .addComponent(send))
                .addGap(21, 21, 21))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formWindowClosing(java.awt.event.WindowEvent evt) throws IOException {//GEN-FIRST:event_formWindowClosing
        // TODO add your handling code here:
        // Send to server to close connection
        outputStream.writeUTF("exit");

        // Write the footer
        closeHTML(fr);

        // Close the file
        fr.close();

        // One way chatterbot learn
        bot.writeQuit();

        System.exit(0);
    }//GEN-LAST:event_formWindowClosing

    private void sendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendActionPerformed
        // TODO add your handling code here:
        try {
            String textClient;
            String emotion;

            // Read what client write
            textClient = fieldclient.getText().trim();

            if (!textClient.equals("exit")) {
                // Get the emotion that are present in what client write
                emotion = getEmotion(textClient);

                // Write what client write in HTML
                writeTextClient(fr, textClient, emotion);

                // Write the message in chat
                conversation.setText(conversation.getText().trim() + "\n>CLIENT : " + textClient + " ( " + getEmotion(textClient) + " ) ");
            }

            // Clean fields
            fieldclient.setText("");
            suggestion.setText("");

            // Send to client
            outputStream.writeUTF(textClient);

        } catch (Exception e) {
        }

    }//GEN-LAST:event_sendActionPerformed

    // Split the text by spaces and for each word associate a number of emotion
    // Give the emotion with highest value or instead alphabetical order or Neutral with don't found emotions
    private static String getEmotion(String text) {
        String emotion = "Neutral";
        String cvsSplitBy = " ";
        int max = 0;

        TreeMap<String, Integer> emotionmap = new TreeMap<>();

        String[] dados = text.split(cvsSplitBy);

        for (int i = 0; i < dados.length; i++) {
            if (positive.contains(dados[i])) {
                if (emotionmap.containsKey("positive")) {
                    int value = emotionmap.get("positive");
                    value = value + 1;
                    emotionmap.replace("positive", value);
                } else {
                    emotionmap.put("positive", 1);
                }
            }
            if (negative.contains(dados[i])) {
                if (emotionmap.containsKey("negative")) {
                    int value = emotionmap.get("negative");
                    value = value + 1;
                    emotionmap.replace("negative", value);
                } else {
                    emotionmap.put("negative", 1);
                }
            }
            if (anger.contains(dados[i])) {
                if (emotionmap.containsKey("anger")) {
                    int value = emotionmap.get("anger");
                    value = value + 1;
                    emotionmap.replace("anger", value);
                } else {
                    emotionmap.put("anger", 1);
                }
            }
            if (anticipation.contains(dados[i])) {
                if (emotionmap.containsKey("anticipation")) {
                    int value = emotionmap.get("anticipation");
                    value = value + 1;
                    emotionmap.replace("anticipation", value);
                } else {
                    emotionmap.put("anticipation", 1);
                }
            }
            if (disgust.contains(dados[i])) {
                if (emotionmap.containsKey("disgust")) {
                    int value = emotionmap.get("disgust");
                    value = value + 1;
                    emotionmap.replace("disgust", value);
                } else {
                    emotionmap.put("disgust", 1);
                }
            }
            if (fear.contains(dados[i])) {
                if (emotionmap.containsKey("fear")) {
                    int value = emotionmap.get("fear");
                    value = value + 1;
                    emotionmap.replace("fear", value);
                } else {
                    emotionmap.put("fear", 1);
                }
            }
            if (joy.contains(dados[i])) {
                if (emotionmap.containsKey("joy")) {
                    int value = emotionmap.get("joy");
                    value = value + 1;
                    emotionmap.replace("joy", value);
                } else {
                    emotionmap.put("joy", 1);
                }
            }
            if (sadness.contains(dados[i])) {
                if (emotionmap.containsKey("sadness")) {
                    int value = emotionmap.get("sadness");
                    value = value + 1;
                    emotionmap.replace("sadness", value);
                } else {
                    emotionmap.put("sadness", 1);
                }
            }
            if (surprise.contains(dados[i])) {
                if (emotionmap.containsKey("surprise")) {
                    int value = emotionmap.get("surprise");
                    value = value + 1;
                    emotionmap.replace("surprise", value);
                } else {
                    emotionmap.put("surprise", 1);
                }
            }
            if (trust.contains(dados[i])) {
                if (emotionmap.containsKey("trust")) {
                    int value = emotionmap.get("trust");
                    value = value + 1;
                    emotionmap.replace("trust", value);
                } else {
                    emotionmap.put("trust", 1);
                }
            }
        }

        if (emotionmap.size() != 0) {
            for (Map.Entry<String, Integer> stringIntegerEntry : emotionmap.entrySet()) {
                if (stringIntegerEntry.getValue() > max) {
                    max = stringIntegerEntry.getValue();
                    emotion = stringIntegerEntry.getKey();
                }
            }
        }

        return emotion;
    }

    // Get the resources
    private static String getResourcesPath() {
        File currDir = new File(".");
        String path = currDir.getAbsolutePath();
        path = path.substring(0, path.length() - 2);
        return path + File.separator + "src" + File.separator + "main" + File.separator + "resources";
    }

    // Write the header of HTML file
    private static void writeHeader(FileWriter fr) throws IOException {
        fr.write("<html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html\"; charset=\"UTF-8\"> <title> Chat Messages </title>  <style>\n" +
                "body {\n" +
                "  margin: 0 auto;\n" +
                "  max-width: 800px;\n" +
                "  padding: 0 20px;\n" +
                "}\n" +
                "\n" +
                ".container {\n" +
                "  border: 2px solid #dedede;\n" +
                "  background-color: #f1f1f1;\n" +
                "  border-radius: 5px;\n" +
                "  padding: 10px;\n" +
                "  margin: 10px 0;\n" +
                "}\n" +
                "\n" +
                ".darker {\n" +
                "  border-color: #ccc;\n" +
                "  background-color: #ddd;\n" +
                "}\n" +
                "\n" +
                ".container::after {\n" +
                "  content: \"\";\n" +
                "  clear: both;\n" +
                "  display: table;\n" +
                "}\n" +
                "\n" +
                ".container img {\n" +
                "  float: left;\n" +
                "  max-width: 60px;\n" +
                "  width: 100%;\n" +
                "  margin-right: 20px;\n" +
                "  border-radius: 50%;\n" +
                "}\n" +
                "\n" +
                ".container img.right {\n" +
                "  float: right;\n" +
                "  margin-left: 20px;\n" +
                "  margin-right:0;\n" +
                "}\n" +
                "\n" +
                ".time-right {\n" +
                "  float: right;\n" +
                "  color: #aaa;\n" +
                "}\n" +
                "\n" +
                ".time-left {\n" +
                "  float: left;\n" +
                "  color: #999;\n" +
                "}\n" +
                "</style> " + "<meta charset=\"utf-8\"/>\n" +
                "            <link rel=\"stylesheet\" href=\"html/w3.css\"/>" +
                "</head> <body>");
    }

    // Write what client say in html file
    private static void writeTextClient(FileWriter fr, String textClient, String emotion) throws IOException {
        LocalTime now = LocalTime.now();
        fr.write("<div class=\"container\">\n" +
                "  <img src=\"html/person.png\" alt=\"Avatar\" style=\"width:100%;\">\n" +
                "  <p>" + "<b>[" + emotion + "]</b></p>\n" +
                "  <p> " + textClient + "</p>\n" +
                "  <span class=\"time-right\">" + now.format(DateTimeFormatter.ofPattern("HH:mm")) + "</span>\n" +
                "</div>");
    }

    // Write what client say in html file
    private static void writeTextServer(FileWriter fr, String textServer, String emotion) throws IOException {
        LocalTime now = LocalTime.now();
        fr.write("<div class=\"container darker\">\n" +
                "  <img src=\"html/anonymous.png\" alt=\"Avatar\" class=\"right\" style=\"width:100%;\">\n" +
                "  <p>" + "<b>[" + emotion + "]</b></p>\n" +
                "  <p>" + textServer + "</p>\n" +
                "  <span class=\"time-left\">" + now.format(DateTimeFormatter.ofPattern("HH:mm")) + "</span>\n" +
                "</div>");
    }

    // Write the footer of HTML file
    private static void closeHTML(FileWriter fr) throws IOException {
        fr.write("</body>\n" + "</html>");
    }

    // Search all csv file given and fills in the list with respective emotion
    private static void registerEmotions(String csvFile) throws IOException {
        String line = "";
        String cvsSplitBy = ";";
        int i = 0;

        BufferedReader br = new BufferedReader(new FileReader(csvFile));

        while ((line = br.readLine()) != null) {
            String[] dados = line.split(cvsSplitBy);
            if (i != 0) {
                if (dados.length == 11) {
                    if (Integer.parseInt(dados[1]) == 1) {
                        positive.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[2]) == 1) {
                        negative.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[3]) == 1) {
                        anger.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[4]) == 1) {
                        anticipation.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[5]) == 1) {
                        disgust.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[6]) == 1) {
                        fear.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[7]) == 1) {
                        joy.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[8]) == 1) {
                        sadness.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[9]) == 1) {
                        surprise.add(dados[0]);
                    }
                    if (Integer.parseInt(dados[10]) == 1) {
                        trust.add(dados[0]);
                    }
                }
            }
            i++;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws IOException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ClientJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ClientJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ClientJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ClientJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ClientJFrame().setVisible(true);
            }
        });

        /* COMMUNICATION */
        socket = new Socket("127.0.0.1", 12345);
        inputStream = new DataInputStream(socket.getInputStream());
        outputStream = new DataOutputStream(socket.getOutputStream());

        /* EMOTIONS */
        registerEmotions("csv\\NRC-Emotion-Lexicon.csv");
        String emotion = "";

        /* CHATTERBOT */
        MagicBooleans.trace_mode = false;
        // Create a bot with name super and all AIML files present in resources directory
        bot = new Bot("super", getResourcesPath());
        // Create a chatSession to learn in conversation and get the previous messages
        Chat chatSession = new Chat(new Bot("super", getResourcesPath()));
        bot.brain.nodeStats();

        /* FILE */
        File fileChat;
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        Date d = new Date();
        String filename = dateFormat.format(d) + ".html";
        // Creating a file with actual hour to save all interactions with chatterbot
        fileChat = new File(filename);
        if (fileChat.createNewFile()) {
            System.out.println("File created: " + fileChat.getName() + "\n");
        } else {
            System.out.println("File already exists.\n");
        }
        fr = new FileWriter(fileChat, false);

        writeHeader(fr);

        String textServer = "";
        while (!textServer.equals("exit")) {
            // Read what server send
            textServer = inputStream.readUTF();

            if (!textServer.equals("exit")) {
                // Get the emotion that are present in what server write
                emotion = getEmotion(textServer);

                // Write what server write in HTML
                writeTextServer(fr, textServer, emotion);

                // Write the message in chat
                conversation.setText(conversation.getText().trim() + "\n-SERVER : " + textServer + " ( " + getEmotion(textServer) + " ) ");
            }

            if ((textServer == null) || (textServer.length() < 1)) {
                textServer = MagicStrings.null_input;
            } else if (!(textServer.equals("exit"))) {
                if (MagicBooleans.trace_mode) {
                    System.out.println("STATE=" + textServer + ":THAT=" + chatSession.thatHistory.get(0).get(0) + ":TOPIC=" + chatSession.predicates.get("topic"));
                }

                // Get the answer give by chatbot dependent of text that human write
                String response = chatSession.multisentenceRespond(textServer);

                while (response.contains("&lt;")) {
                    response = response.replace("&lt;", "<");
                }
                while (response.contains("&gt;")) {
                    response = response.replace("&gt;", ">");
                }

                // Write what chatterbot like a suggestion
                suggestion.setText(response);
            }
        }

        socket.shutdownOutput();
        socket.shutdownInput();
        socket.close();

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JTextArea conversation;
    private javax.swing.JTextField fieldclient;
    private static javax.swing.JLabel fix_conversation;
    private javax.swing.JLabel fix_suggestion;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton send;
    private static javax.swing.JTextArea suggestion;
    // End of variables declaration//GEN-END:variables
}
